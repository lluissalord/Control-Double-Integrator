\documentclass[12pt,a4paper,final,twoside,openright]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[catalan]{babel}

\usepackage{setspace}
\onehalfspacing

\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{hyperref}

\usepackage{epstopdf}

\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[RO,LE]{\thepage}
\fancyhead[RE,LO]{Control d'un doble integrador}
\fancyfoot{}
\fancyfoot[RO,LE]{\includegraphics[scale=0.5]{Imatges/etseib.png}}


\usepackage{appendix}
\renewcommand{\appendixname}{Annexos}
\renewcommand{\appendixtocname}{Annexos}
\renewcommand{\appendixpagename}{Annexos}


\usepackage{chngcntr}
\counterwithin{figure}{chapter}%Permet que el comptatge de les figures sigui segons capitol
\counterwithin{table}{chapter}
\counterwithin{equation}{chapter}
\counterwithin{footnote}{chapter}

%PLANTEJAR TEMA DE \autoref{} ja que així l'hiperenllaç es també per la paraula i no sols el numero.

\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}}
\renewcommand{\thetable}{\arabic{chapter}.\arabic{table}}
\renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
\renewcommand{\thefootnote}{\arabic{footnote}}

\usepackage{etoolbox}
\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{fancy}}{}{}

\headheight = 15pt %Donava un warning sino

\textheight = 690pt %Col·locació de l'escut a distancia que quedi be
\footskip = 60pt


\title{Tecnologia de Control \\ Control d'un doble integrador}
\author{Alumne: Lluís Salord Quetglas \\ Professor: Manel Velasco}
\date{Novembre 2015}

\begin{document}

\maketitle
\thispagestyle{empty}

\cleardoublepage

\setcounter{page}{1} %Començar en la pagina 1

\begin{abstract}
\addcontentsline{toc}{chapter}{Resum}

Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova. Text de prova.

\end{abstract}

\tableofcontents

\listoffigures

\listoftables

\chapter{Introducció}

En l'àmbit d'aquesta assignatura es pretén aplicar els diferents coneixements de control de plantes que s'han adquirit al llarg de la carrera. Com a primera planta s'ha plantejat la d'un \textit{DI} (doble integrador). En aquest cas, pel fet de ser un doble integrador té dos pols en el zero i per tant és per ella mateixa una planta inestable.

En aquest informe es pretén explicar els procediments que s'han seguit per dur a terme el control d'aquesta planta amb els diferents mètodes utilitzats, argumentant quines implicacions té cadascun d'aquests. El control és du a terme a través d'una placa Arduino que es connecta directament a la placa a controlar.

Els diferents mètodes que s'han utilitzat per fer el control primer s'han simulat i fet els càlculs amb \texttt{Matlab} i la \textit{toolbox} \texttt{Simulink}. Tot seguit, s'ha connectat l'Arduino a l'ordinador per introduir-hi i executar el codi de control per finalment connectar la placa a controlar amb l'Arduino.



\section{Planta a controlar}

En aquest cas la planta a controlar és un placa que conté un doble integrador. El fet de tenir dos pols en el zero provoca que sigui inestable. L'esquemàtic del doble integrador és el que s'il·lustra a la figura \ref{fig:doble_int_scheme}.

 Aquesta placa té diverses connexions per tal de comunicar-se amb l'exterior i que sigui controlable de diverses formes. Aquestes són, per una banda, les entrades de 5 V i l'acció de control \textit{u}; i per altra banda, els punts $V_1$, $V_2$ i el \textit{GND} (0 V del circuit). La relació de les connexions entre el doble integrador i l'Arduino és la que es mostra en la taula \ref{tab:con_DI_Ard}. En aquestes connexions sobretot s'ha de tenir en compte que les entrades pel \textit{DI}, són sortides per l'Arduino i a l'inrevés. Per tant, \textit{D6} s'ha de configurar com a sortida, a més de tipus \textit{PWM}, i per altra banda, \textit{A5} i \textit{A6} com a entrades en l'Arduino.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{Imatges/circuit_scheme.png}
\caption{Esquemàtic del doble integrador instal·lat a la placa \label{fig:doble_int_scheme}}
\end{figure}

\begin{table}[ht]
\begin{center}
\begin{tabular}{l|l}
Arduino & Doble Integrador\\
\hline
5v & 5v (LM358N power)\\
IOREF & 5v (voltage divider input)\\
GND & GND\\
A5 & $V_1$ DI output voltage\\
A4 & $V_2$ DI output voltage\\
D6 & u (PWM)
\end{tabular}
\caption{Taula de connexions entre el doble integrador i ports de l'Arduino \label{tab:con_DI_Ard}}
\end{center}
\end{table}

\newpage %Per no tallar el paragraf amb les figures superiors
Finalment, sobre el \textit{DI} només queda comentar el model matemàtic d'aquest. Desenvolupant les equacions de la dinàmica del circuit electrònic de la figura \ref{fig:doble_int_scheme} s'arriba a les equacions \eqref{eq:V1} i \eqref{eq:V2}. A partir d'aquestes equacions i dels valors numèrics de la figura \ref{fig:doble_int_scheme} s'arriba al model matemàtic del doble integrador que s'utilitza, expressat com \eqref{eq:DI_model_1}, \eqref{eq:DI_model_2} i amb els valors de \eqref{eq:DI_values} per les matrius del sistema de la planta .

\begin{eqnarray}
\dot{V_1} = - \frac{u}{R_2 C_2}\label{eq:V1} \\
\dot{V_2} = - \frac{V_2}{R_1 C_1}\label{eq:V2}
\end{eqnarray}

\begin{equation}\label{eq:DI_model_1}
\begin{bmatrix}
\dot{x_1}\\
\dot{x_2}
\end{bmatrix}
=
A_g
\begin{bmatrix}
x_1\\
x_2
\end{bmatrix}
+
B_g
u
\end{equation}

\begin{equation}\label{eq:DI_model_2}
y = C_g
\begin{bmatrix}
x_1\\
x_2
\end{bmatrix}
+ D_g
\end{equation}

\begin{equation}\label{eq:DI_values}
A_g = \begin{bmatrix}
0 & -23.8095\\
0 & 0
\end{bmatrix}
~~
B_g = \begin{bmatrix}
0 \\
-23.8095
\end{bmatrix}
~~
C_g = \begin{bmatrix}
1 & 0
\end{bmatrix}
~~
D_g = 0
\end{equation}

\newpage
\section{Metodologia}

En aquesta assignatura es treballa directament amb la planta a controlar i l'Arduino que és la que porta el control d'aquesta. Ara bé, abans d'implementar el control primer s'han de fer les simulacions pertinents. A més, en haver-se incorporat el codi de control en l'Arduino, s'ha de comprovar que aquest s'està duent a terme de forma correcte. Aquesta metodologia de treball és du a terme en cadascun dels tipus de control que es duen a terme en el treball. Tot seguit s'explica en detall quines accions i programari s'utilitza per fer-ho.

El primer és dur a terme la simulació del conjunt planta-controlador. Aquesta es fa amb la \textit{toolbox} \texttt{Simulink} havent fet els càlculs previs amb \texttt{Matlab}, tals com matrius d'alguns sistemes o valors dels controlador. En les simulacions s'extreuen les dades que es creguin convenients per tal d'esser analitzades, tant per comprovar si el sistema es controlat teòricament amb precisió, com per esser contrastades després amb les dades reals.

En tenir el sistema simulat i amb un controlador adient s'ha de procedir a implementar aquest a través de l'Arduino. Per fer-ho s'han de transformar el conjunt de blocs de simulació a equacions i codi. Aquesta tasca és més complicada del que sembla, aquí es demostra com de clars es tenen els coneixements i és molt fàcil equivocar-se en algun punt, tot i ser un simple detall.

Finalment s'ha de comprovar el bon funcionament del control. Per dur a terme aquesta fase el primer és tenir alguna sortida de dades del sistema real. En aquest cas, s'utilitza el \texttt{Serial Port} de l'Arduino on a través de les funcions \texttt{Serial.print} i \texttt{Serial.println} esdevenen sortides del que es desitgi. Per l'estudi en qüestió s'envien les variables que intervenen en el sistema al \texttt{Serial Port} com són: les variables d'estat $V_1$ i $V_2$, la referència, l'acció de control $u$ i altres variables que poden ser importants segons el control que es faci. Al treure les dades pel \texttt{Serial Port}, si s'envien seguint cert patrons, poden ser llegides i plotejades \textit{online} amb el programa \texttt{KST} per exemple, o també poder ser emmagatzemades en un fitxer per després ser analitzades amb \texttt{Matlab}. Amb les dades plotejades es pot comprovar la precisió del control o comparar-les amb les dades extretes de les simulacions.

\paragraph{$ $}

\section{Repositori de la pràctica}\label{sec:github}
En aquest tipus de pràctiques és molt comú l'ús de molt codi. Per tant, posar tota la informació en els Annexos pot ser molt incòmode, tant a l'hora de provar-ho, com si es vol corregir alguna errada. Per això es creu que el més convenient és posar tots els fitxers de codi, incluint el \texttt{Tex} del pròpi informe, en la plataforma \texttt{GitHub}.

La URL del repositori d'aquesta pràctica és:

\url{https://github.com/lluissalord/Control-Double-Integrator.git}

En aquest repositori es troben els diferents codis Arduino, fitxers format \texttt{.m} de \texttt{Matlab}, juntament amb els models de \texttt{Simulink} i els fitxers i imatges necessaris per dur a terme l'informe.

\chapter{Control de la planta}

La planta d'estudi es pot arribar a controlar de diverses formes, portant totes elles a l'estabilitat. Algunes porten l'estat a la referència amb més imprecisió que d'altres, com es comprova al llarg del treball, però totes elles provoquen que la planta sigui estable, que és l'objectiu del control. En aquesta part del treball és pretén explicar com s'han duit a terme els diferents controls i les característiques de cadascun d'ells.

\section{Control continu}

El control més senzill que es pot arribar a fer és considerar que el conjunt del sistema, planta-controlador, és en temps continu. En aquest cas, el sistema tan sols requereix del bloc de la planta, que utilitza els valors de les matrius de l'equació \eqref{eq:DI_values}, i una realimentació d'estat $K$, tal que els pols de llaç tancat siguin de part real negativa o nul·la (només si es un pol simple). Aquest tipus de sistema és simula amb l'esquemàtic de la figura \ref{fig:cont_scheme}.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{Imatges/cont_sim_scheme.pdf}
\caption{Model de simulació del sistema amb control continu\label{fig:cont_scheme}}
\end{figure}

A banda del que s'acaba d'explicar, en la figura \ref{fig:cont_scheme} també apareixen una referència que es pretén seguir i el bloc $N_x$. Aquest permet que el sistema segueixi la referència donada. Per altra banda, també s'hi hauria d'incloure un bloc $N_u$ que multiplicaria la referència i es sumaria a l'acció de control $u$ a l'entrada de la planta, però com es veu en els càlculs de les equacions \eqref{eq:Nx_Nu}, $N_u$ és igual a zero. El sistema \eqref{eq:Nx_Nu} surt de desenvolupar els requisits \eqref{eq:req_N} per tal que es segueixi la referència. 

\begin{equation}\label{eq:req_N}
\left\{
\begin{array}{lr}
N_x r = x_r = x_ss \\
C_r X_ss = y_r = r
\end{array}
\right.
\end{equation}

\begin{equation}\label{eq:Nx_Nu}
\begin{bmatrix}
N_x\\
N_u
\end{bmatrix}
=
\begin{bmatrix}
A_g & B_g\\
C_g & 0
\end{bmatrix}^{-1}
\begin{bmatrix}
0\\
0\\
1
\end{bmatrix}
=
\begin{bmatrix}
1\\
0\\
0
\end{bmatrix}
\Rightarrow \left\{
\begin{array}{lr}
N_x = \begin{bmatrix}
1\\
0
\end{bmatrix} \\
N_u = 0
\end{array}
\right.
\end{equation}

Un cop es té el sistema montat de tal manera que aquest pugui seguir una referència, s'ha de buscar el controlador $K$ tal que porti el sistema a error zero. Per aconseguir-ho, existeixen diverses formes depenent de si es pensen imposar uns pols de llaç tancat determinats (per assignació de pols o amb la formula d'Ackermann) o si es pretén fer un control òptim a partir d'una funció de cost determinada (control \texttt{LQR}). En el cas d'estudi, s'utilitza la formula d'Ackermann imposant un pols de llaç tancat amb part real negativa o nul·la (només si és un pol simple).

Els pols que s'han d'imposar com s'ha dit abans han de ser uns que siguin de part real negativa o nul·la. Ara bé, en aquest sistema s'han d'escollir dos pols, per tant, aquests no poden ser de part real nul·la ja que farien el sistema inestable. Finalment, s'han escollit els pols $-5\pm20i$ que compleixen el requisit i que ha sigut proposat pel professor. 

Un cop escollits els pols tan sols queda aplicar la formula d'Ackermann. Aquesta dona el valor $K$ del controlador donats els pols desitjats i les matrius $A$ i $B$ del sistema. Al cap i a la fi, dona el mateix resultat que l'assignació de pols on s'iguala el polinomi característic desitjat amb $|z \mathbf{I} - (\mathbf{A_g} - \mathbf{B_g K})|$. La formula consisteix en l'equació \eqref{eq:Acker} on $p_d(A_g)$ és el polinomi característic desitjat amb el valor de la matriu $A_g$. En el \texttt{Matlab} la funció \texttt{acker} s'encarrega de fer aquests càlculs\footnote{Si es desitja llegir el codi \texttt{Matlab} utilitzat per fer tots els càlculs es pot trobar en el \texttt{GitHub} que es dona en la secció \ref{sec:github}}.

\vspace{-10pt}
\begin{equation}\label{eq:Acker}
K=(0\quad0\quad0\quad\dots\quad1)(\mathbf{A_g}\quad \mathbf{A_g B_g}\quad \mathbf{A_g^2 B_g}\quad \dots\quad \mathbf{A_g^{n-1} B_g})^{-1} p_d(A_g)
\end{equation}

Al tenir tots els valors es procedeix a dur a terme les simulacions. Les dades plotejades es mostren en la figura \ref{fig:cont_sim}. Aquí es pot veure com, en la simulació, s'aconsegueix estabilitzar la planta, tot i venir d'unes condicions inicials diferents a zero. Ara bé, aquesta simulació no s'adapta a la realitat, ja que l'Arduino envia l'acció de control de forma discreta i per tant el control no es correcte. Tot i que en aquest cas s'ha comprovat experimentalment que igualment es controla, tot i que no de la forma desitjada. Per tant, d'aquest tipus de control no se'n fa l'anàlisi experimental amb l'Arduino. 

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{Imatges/cont_sim.eps}
\caption{Dades de la simulació amb control continu\label{fig:cont_sim}}
\end{figure}

D'aquest cas no se'n fa un anàlisi en profunditat ja que no té especialment sentit físic. Només destacar, com es veu en la figura \ref{fig:cont_sim}, el fet que es demostra que una planta inestable, amb el controlador adequat por permetre l'estabilització del sistema.

\section{Control discret}

Com s'ha explicat en el cas del control continu, aquest no reflecteix la realitat, ja que el controlador (l'Arduino) funciona de forma discreta. Aquest llegeix les dades i fa els càlculs un cop cada cert temps, i envia el mateix valor del senyal durant aquest període.

El fet que es consideri el controlador discret no s'ha de confondre en que la planta funcioni de forma discreta. La planta és continua, l'únic que passa és que l'entrada, almenys la part que prové del controlador, és discreta i per tant el controlador s'ha d'adaptar a aquest tipus de funcionament. 

El primer que s'ha de fer és saber a quina freqüència treballa el controlador. En aquest cas, s'ha estipulat en l'enunciat un funcionament a $20 Hz$ (període de mostreig de $0.05 s$). Posteriorment, s'han de plantejar els pols de llaç tancat del sistema. Per simplificar, s'han escollit els mateixos que en el control continu, però discretitzats, que és fa aplicant l'equació \eqref{eq:pol_dis} als pols continus, sent $T_s$ el període de mostreig del controlador. Aplicant \eqref{eq:pol_dis} als pols continus, $-5\pm20i$, de l'apartat anterior, en resulten els pols discrets $0.4208\pm0.6553i$. El mòdul d'aquests pols és $0.7788$ es troben dins el cercle unitari, per tant, són estables. 

\begin{equation}\label{eq:pol_dis}
P_{dis} = e^{T_s P_{cont}}
\end{equation}
\vspace{10pt}


Per últim càlcul queda la $K$ del controlador, que es designa al llarg de treball com $K_{dis}$. Per tal d'aconseguir-ho també es pretén utilitzar la formula d'Ackermann \eqref{eq:Acker}, però no s'utilitzen les matrius $A_g$ i $B_g$, sinó les seves transformacions al sistema discret amb el període de mostreig $T_s$. Aquesta transformació es pot fer a través de la funció \texttt{c2d} del \texttt{Matlab}, on donades les matrius del sistema continu i el període de mostreig $T_s$ dona les matrius $\Phi$ i $\Gamma$ del sistema discret amb valors \eqref{eq:phi_gam}. Finalment, s'introdueixen les matrius $\Phi$ i $\Gamma$ i el període de mostreig a la funció \texttt{acker} i es té com a resultat el controlador $K_{dis} = \begin{bmatrix}
0.5398 & -0.6518
\end{bmatrix}$.\label{pag:trans_phi_gam}

\begin{equation}\label{eq:phi_gam}
\Phi=\begin{bmatrix}
1 &	-1,1905\\
0 & 1
\end{bmatrix} \;\;\;\;\;\;\; \Gamma=\begin{bmatrix}
0,7086\\
-1,1905
\end{bmatrix}
\end{equation}

Un cop és tenen tots els càlculs fets s'ha de procedir a dur a terme la simulació amb \texttt{Simulink}. El model de simulació és l'exposat en la figura \ref{fig:dis_sim_scheme}. A partir d'aquest, en surt el gràfic de la figura \ref{fig:dis_sim} que descriu la dinàmica del sistema amb el mateix tipus de referència que després s'utilitza en l'Arduino. Com es pot comprovar tendeix al valor de la referència en l'estacionari.

\begin{figure}[t]
\centering
\includegraphics[width=0.8\textwidth]{Imatges/dis_sim_scheme.pdf}
\caption{Model de simulació del sistema amb control en discret\label{fig:dis_sim_scheme}}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{Imatges/dis_sim.eps}
\caption{Dades de la simulació amb control discret\label{fig:dis_sim}}
\end{figure}

\newpage
Aquest al ser un cas més realista si que s'ha portat a fer les proves amb l'Arduino, per tal de veure si el comportament simulat i el real equivalen. A l'hora d'implementar el sistema en l'Arduino es pren la plantilla base de l'enunciat de la pràctica on tan sols falta l'algorisme de control y els valors de les constants. L'algorisme es basa en l'equació \eqref{eq:dis_u} on $V = \begin{bmatrix}
V_1\\
V_2
\end{bmatrix}$ i $r$ la referència que es pretén seguir.

\begin{equation}\label{eq:dis_u}
u=K_{dis} (N_x \cdot r - V) + N_u \cdot r
\end{equation}

Ara bé, s'han de tenir una sèrie de detalls en compte a l'hora d'implementar a l'Arduino:

\begin{itemize}
\item Al llegir les variables de l'exterior ($V_1$ i $V_2$) amb \texttt{analogRead} aquesta esta escalada entre 0 i 1023.
\item Al escriure pel \texttt{PWM} s'ha d'escalar entre 0 i 256.
\item Els voltatges estan \textit{offsejats} $2.5$ V a l'alça. Per tant, després de llegir i transformar a volts s'ha de restar $2.5$, per $V_1$ i $V_2$, i per $u$ abans d'enviar s'ha sumar $2.5$ per estar en referència absoluta.
\item S'ha de treballar amb variables tipus \texttt{float} o \texttt{double} per tal de fer els càlculs correctament.
\item La referència oscil·la entre $0.5$ i $1.5$ volts en lloc d'entre $1$ i $-1$ volts ja que sinó en algun moment s'arribava a la saturació i el funcionament no era del tot exacte.
\end{itemize}

Un cop passat a codi les equacions tenint en compte els punt anterior només s'ha d'afegir la part de codi que permet la lectura de les variables des de l'exterior. Això es du a terme a traves del \texttt{Serial Port} on amb la comanda \texttt{Serial.print} i \texttt{Serial.println} permet transmetre el que es desitgi. En aquest cas, s'envien les variables $V_1$, $V_2$, $U$ i la referència, totes aquestes en referència absoluta. Finalment, tan sols queda compilar i transferir el codi a l'Arduino.

A l'hora de comprovar que està passant a l'Arduino s'han arribat a utilitzar tres mètodes diferents segons el que es desitgi fer:

\begin{itemize}
\item Finestra del \texttt{Serial Port}, que es troba en la mateixa \texttt{IDE} de l'Arduino. Aquí es veu directament el que s'envia.
\item Programa \texttt{KST}, el qual si les variables s'envien amb un cert format es poden \textit{plotejar} en temps real.
\item A través de \texttt{Matlab}, un cop finalitzada l'escriptura de l'enviament de dades en un fitxer, importar les dades d'aquest.
\end{itemize}

D'aquests casos, tant el \texttt{KST} com el \texttt{Matlab}, requereixen de l'escriptura del que transmet el \texttt{Serial Port} en un arxiu de text. Això es pot fer utilitzant la comanda següent:

\texttt{cu -l /dev/ttyACM0 -s 115200 > nom\_arxiu.txt}

\vspace{10pt}
En cas del control discret les dades que s'han pogut extreure de l'Arduino són les que s'exposen en la figura \ref{fig:dis_all}. Com es pot observar, en aquest cas segueix molt bé la senyal, amb un petit soroll probablement degut al sensor a l'hora de llegir la senyal. Per tant, dur a terme una realimentació d'estat és un sistema de control que dona un bon resultat.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{Imatges/dis_all.eps}
\caption{Dades de l'Arduino amb control discret\label{fig:dis_all}}
\end{figure}

\section{Control amb observador}

Dur a terme una realimentació d'estat obliga a tenir un sensor per cadascun dels estats que es controlen. Aquest fet comporta un cost enorme en sensors. Per això, en molts cops es tendeix a fer el control de tot un sistema tan sols utilitzant un o uns pocs estats i per tant amb menys sensors. Per fer-ho s'utilitza un observador, que equivaldria a una simulació de la planta, però amb l'ús d'un o més dels estats reals per tal de portar sempre aquest observador al valor real.

Ara bé, no es pot implementar un control amb observador a qualsevol planta, aquestes han de complir que siguin observables, per tant que a partir de l'estat observat i l'acció de control es poden deduir tots els estats en un nombre finit de períodes $n$. Això es compleix si la matriu $W_o$ de l'equació \eqref{eq:observabilitat} és de rang $n$. En el cas d'estudi, el sistema es observable, i per tant, es pot dur a terme el control amb observador.
\vspace{-10pt}

\begin{equation}\label{eq:observabilitat}
W_o = \begin{bmatrix}
C\\
C A\\
C A^2\\
\vdots\\
C A^{n-1}
\end{bmatrix}
\end{equation}

La idea de l'observador és a partir del model de la planta, la sortida $y$ de la planta y l'acció de control $u$, estimar els estats de la planta i utilitzar aquesta estimació per realimentar el sistema, $u_k = -K_{dis}\cdot\bar{x}_k$. En aquest cas, s'ha considerat la matriu $C_g=[1 ~ 0]$, per tant, la sortida $y$ és $V_1$. Tenir en compte que l'observador, en la realitat, es troba en l'Arduino, per tant, és un sistema discret. Per això el model de la planta que s'utilitza en l'observador és el de la planta original passat a discret\footnote{El procés està explicat en la secció anterior a la pàgina \pageref{pag:trans_phi_gam}}, per tant, utilitza $\Phi$ i $\Gamma$.

Per altra banda, a l'hora d'escollir els pols, s'ha basat en utilitzar uns pols un poc més ràpids que els de la planta per a poder arribar al seu valor real, però no molt més per no amplificar el soroll que hi pugui haver. Per això, s'ha prés la part real dels pols de la planat i s'ha multiplicat per dos, sent així els pols de l'observador: $-10\pm20i$ en el pla S. 

Un cop escollits els pols, s'ha de procedir al càlcul de la $L$ de l'observador. Si es fes per assignació de pols, s'haurien d'igualar els pols, al polinomi $|z\mathbf{I}-(\mathbf{\Phi} - \mathbf{L C_g})|$. Ara bé, si observem en que es basava la formula d'Ackermann \eqref{eq:Acker}, es pot observar com si ara s'utilitza $\Phi^T$ i $C_g^T$ en lloc de $A_g$ i $B_g$ aquesta formula donaria com a resultat $L^T$. En aquest cas, s'ha utilitzat la formula de Ackermann de la forma anterior i ha donat com a resultat $L=\begin{bmatrix}
1,3446\\
-0,5985
\end{bmatrix}$

Com en tots els casos, un cop es tenen els valors de les matrius a utilitzar i les constants dels controladors, es procedeix a fer la simulació en \texttt{Simulink}. En aquest cas, el model queda expressat com en la figura \ref{fig:obs_sim_scheme}. El model de l'observador es basa en l'equació \eqref{eq:obs_model}. S'ha de tenir en compte el fet que la sortida de la planta a controlar és continua, per tant a l'hora d'utilitzar $y_k$, aquesta s'ha de discretitzar a la mateixa freqüència de treball del controlador per ser realista. A més, al voler tenir la informació de tots els estats, tot i ser $C_g=$[1 0], en la el bloc d'Espai d'Estats s'ha donat una $C$ igual a la identitat i així poder llegir els estats, sent posteriorment multiplicat per  $C_g$ per donar la sortida.

\begin{equation}\label{eq:obs_model}
\bar{x}_{k+1} = \Phi \bar{x}_k + \Gamma u_k + L (y_k - C_g \bar{x}_k)
\end{equation}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{Imatges/obs_sim_scheme.pdf}
\caption{Model de simulació del sistema amb control amb observador\label{fig:obs_sim_scheme}}
\end{figure}


\section{Control amb refús de pertorbació}

\subsection{Pertorbació constant}

\subsection{Pertorbació sinusoïdal}

\subsection{Pertorbació constant i sinusoïdal}

\section{Ús de pols reals de l'observador}
%S'ha vist que hi ha unes freqüencies molt altes i s'ha pensat en que poden ser degudes als pols de l'observador que s'han posat, per això es decideix a procedir amb l'ús de pols reals en lloc dels proposats a l'inici.
%Després també es veu com el fet que siguin ràpids no es necessari ja que es preten refusar un senyal que es sempre igual. Es veu en la transformada de fourier.

%\bibliography{./Bibliografia/library}
%\addcontentsline{toc}{chapter}{Referències}
%\label{Referencies}


\appendix
\clearpage % o \cleardoublepage
\addappheadtotoc
\appendixpage

\chapter{Càlculs per refús de pertorbacions d'un rang de freqüències sinusoïdals}

\end{document}
